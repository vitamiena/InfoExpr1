//====================================================================
//  C言語 中級プログラミング  例題
//  単純整列算法  処理過程
//--------------------------------------------------------------------
//  SimpleSort  SimpleSortProc.c
//  Linux  GCC 4.4
//--------------------------------------------------------------------
//  富永研究室  tominaga 富永浩之
//  2015.06.16
//====================================================================


/*====================================================================
//  仕様
//====================================================================

3種類の単純整列算法とその幾つかの変種を実装する。
ポインタ引数で、比較回数と交換回数をカウントする。
整列過程を表示する。

単純選択法    sel_sort()       未整列部分の最小要素を先頭と交換
単純交換法    exch_sort()      隣接要素を交換して整列部分を伸長
単純挿入法    ins_sort()       整列部分に未整列要素を挿入

撹拌法        shaker_sort()    両方向から交互に交換法
転置法        trans_sort()     奇偶ペアと偶奇ペアを交互に交換
小人法        gnome_sort()     隣接要素を交換しながら前進後退
--------------------------------------------------------------------*/


//====================================================================
//  ヘッダ情報
//====================================================================

#include <stdio.h>
#include "SimpleSortProc.h"


//====================================================================
//  単純整列算法の処理過程  基本
//====================================================================

//--------------------------------------------------------------------
//  単純選択法
//--------------------------------------------------------------------

/* void sel_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)  */
/* { */
/*   int i, j;    // 反復変数 */
/*   int p;       // 最小要素の位置 */
/*   for ( i = 0; i < n-1; i++ ) {  */
/*     p = i;                       */
/*     for ( j = i+1; j < n; j++ ) {                     */
/*       if ( ! arr_ord_ct(arr, p, j, ct_c) ) { p = j; } */
/*     } */
/*     arr_swap_ct(arr, i, p, ct_s); *ct_s += p-i-1;    // p-i回の交換 */
/*     proc_view(arr, n, *ct_c, *ct_s); */
/*   } */
/* } */

///*--------------------------------------------------------------------
void sel_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int i, j;
  for ( i = 0; i < n-1; i++ ) {
    for ( j = i+1; j < n; j++ ) {
      if ( ! arr_ord_ct(arr, i, j, ct_c) ) {
        arr_swap_ct(arr, i, j, ct_s);
      }
    }
    proc_view(arr, n, *ct_c, *ct_s);
  }
}
//--------------------------------------------------------------------*/


/*--------------------------------------------------------------------
比較回数は、常に n(n-1)/2 回である。
交換回数は、0〜n(n-1)/2 回の範囲で、平均 n(n-1)/4 回程度である。

最小位置を格納するだけで、最後に arr_swap() でのみ交換と捉えれば、
n-1回の交換となる。
最小位置の格納も交換と捉えれば、最後の arr_swap() は、
自分自身との交換に相当するので、数えない。
このとき、交換回数は、0〜n(n-1)/2 回の範囲で、平均 n(n-1)/4 回程度である。
--------------------------------------------------------------------*/


//--------------------------------------------------------------------
//  単純交換法
//--------------------------------------------------------------------

void exch_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int i, j;     // 反復変数
  int p = 0;    // パスの左端(最後の交換位置)
  int t;        // 現在の交換位置(交換の有無のフラグとしても利用)
  for ( i = 0; i < n-1; i++ ) {
    t = n;                                        // 未交換という意味でnに初期化
    for ( j = n-1; j > p; j-- ) {                 // 最後に交換した位置まで
      if ( ! arr_ord_ct(arr, j-1, j, ct_c) ) {    // 隣接要素の比較
        arr_swap_ct(arr, j-1, j, ct_s); t = j;    // 隣接要素の交換と交換位置の更新
      }
      proc_view(arr, n, *ct_c, *ct_s);            // 整列過程の表示
    }
    if ( t < n ) { p = t; } else { break; }       // 交換があれば更新し、なければ打切り
  }
}

/*--------------------------------------------------------------------
void exch_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int i, j;
  Bool flag;    // パス内の交換の有無
  for ( i = 0; i < n-1; i++ ) {
    flag = FALSE;    // 交換無に初期化
    for ( j = n-1; j > i; j-- ) {
      if ( ! arr_ord_ct(arr, j-1, j, ct_c) ) {
        arr_swap_ct(arr, j-1, j, ct_s);
        flag = TRUE;    // 交換有に変更
      }
    }
    proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
    if ( ! flag ) { break; }            // 交換無であれば整列終了
  }
}
---------------------------------------------------------------------*/

/*--------------------------------------------------------------------
各パスにおける交換の有無を調べることで、整列に近い場合、比較回数が少し減る。
有無を調べない場合は、比較回数は、常に n(n-1)/2 となる。
さらに、最後に交換した位置も覚えてくと、比較回数を減らせる。
かなり整列された配列に対しては、効果的である。
ただし、ばらけた配列に対しては、それほど効果がない。

交換回数は、単純挿入法と同じである。
交換回数は、0〜n(n-1)/2 回の範囲で、平均 n(n-1)/4 回程度である。
--------------------------------------------------------------------*/


//--------------------------------------------------------------------
//  単純挿入法
//--------------------------------------------------------------------

void ins_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int i, j;
  for ( i = 0; i < n-1; i++ ) {
    for ( j = i; j >= 0; j-- ) {
      if ( arr_ord_ct(arr, j, j+1, ct_c) ) { break; }
      arr_swap_ct(arr, j, j+1, ct_s);
    }
    proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
  }
}

/*--------------------------------------------------------------------
比較回数は、(n-1)〜n(n-1)/2 回の範囲で、平均 n(n-1)/4 回程度である。
break文を用いない場合、比較回数は、単純交換法と同じで、常に n(n-1)/2 回である。

交換回数は、単純交換法と同じである。
交換回数は、0〜n(n-1)/2 回の範囲で、平均 n(n-1)/4 回程度である。
--------------------------------------------------------------------*/


//====================================================================
//  単純整列算法  変種
//====================================================================

//--------------------------------------------------------------------
//  撹拌ソート
//--------------------------------------------------------------------

void shaker_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int i = 0;      // 左端
  int j = n-1;    // 右端
  int k;
  //----
  while ( i < j ) {
    //--  右から左への交換処理
    for ( k = j; k > i; k-- ) {
      if ( ! arr_ord_ct(arr, k-1, k, ct_c) ) {
        arr_swap_ct(arr, k-1, k, ct_s);
      }
      proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
    }
    //--  左から右への交換処理
    for ( k = i; k < j; k++ ) {
      if ( ! arr_ord_ct(arr, k, k+1, ct_c) ) {
        arr_swap_ct(arr, k, k+1, ct_s);
      }
      proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
    }
    i++;    // 左端位置を更新
    j--;    // 右端位置を更新
  }
}

//--------------------------------------------------------------------
//  小人ソート
//--------------------------------------------------------------------

void gnome_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int k = 1;                                  // 左端から開始
  //----
  while ( k < n ) {                           // 右端に達するまで
    //--
    if ( arr_ord_ct(arr, k-1, k, ct_c) ) {
      k++; continue;                          // 正順なら右へ
    }
    //--
    arr_swap_ct(arr, k-1, k, ct_s);           // 逆順なら交換して左へ
    if ( k > 1 ) { k--; } else { k++; }       // 左端なら右へ
    proc_view(arr, n, *ct_c, *ct_s);          // 整列過程の表示
  }
}

//--------------------------------------------------------------------
//  転置ソート
//--------------------------------------------------------------------

void trans_sort_ct(Data arr[], int n, int *ct_c, int *ct_s)
{
  int k;
  int flag;
  //----
  while ( flag ) {    // 交換が行われなくまで
    flag = FALSE;
    //--  奇番-偶番ペアの交換処理
    for ( k = 1; k < n; k += 2 ) {
      if ( ! arr_ord_ct(arr, k-1, k, ct_c) ) {
        arr_swap_ct(arr, k-1, k, ct_s);
        flag = TRUE;
      }
    }
    proc_view(arr, n, *ct_c, *ct_s);
    //--  偶番-奇番ペアの交換処理
    for ( k = 2; k < n; k += 2 ) {
      if ( ! arr_ord_ct(arr, k-1, k, ct_c) ) {
        arr_swap_ct(arr, k-1, k, ct_s);
        flag = TRUE;
      }
    }
    proc_view(arr, n, *ct_c, *ct_s);
  }
}


//====================================================================
//  補助関数
//====================================================================

//--------------------------------------------------------------------
//  配列の要素の比較
//--------------------------------------------------------------------

Bool arr_ord_ct(Data arr[], int p1, int p2, int *ct)
{
  (*ct)++;
  if ( arr[p1] <= arr[p2] ) { return TRUE; }
    else { return FALSE; }
}

//--------------------------------------------------------------------
//  配列の要素の交換
//--------------------------------------------------------------------

void arr_swap_ct(Data arr[], int p1, int p2, int *ct)
{
  Data tmp;
  (*ct)++;
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

//--------------------------------------------------------------------
//  配列の要素の挿入
//--------------------------------------------------------------------

void arr_ins(Data arr[], int m, int p)
{                                                     // m-p回の交換に相当
  Data tmp = arr[m];                                  // データを退避
  int k;
  for ( k = m; k > p; k-- ) { arr[k] = arr[k-1]; }    // データを後方移動
  arr[p] = tmp;                                       // データを挿入
}


//====================================================================
//  配列の入出力
//====================================================================

//--------------------------------------------------------------------
//  配列への入力
//--------------------------------------------------------------------

void arr_input(Data arr[], int n)
{
  int k;
  for ( k = 0; k < n; k++ ) { scanf("%2d", &arr[k]); }
}

//--------------------------------------------------------------------
//  配列からの出力
//--------------------------------------------------------------------

void arr_output(Data arr[], int n)
{
  int k;
  for ( k = 0; k < n; k++ ) { printf("%2d ", arr[k]); }
}

//--------------------------------------------------------------------
//  処理過程の表示
//--------------------------------------------------------------------

void proc_view(Data arr[], int n, int ct_c, int ct_s)
{
  /* printf("%4d  %4d : ", ct_c, ct_s); */
  /* arr_output(arr, n); puts(""); */
}
