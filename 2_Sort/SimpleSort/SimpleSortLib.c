//====================================================================
//  C言語 中級プログラミング  例題
//  単純整列算法  実行結果
//--------------------------------------------------------------------
//  SimpleSort  SimpleSortLib.c
//  Linux  GCC 4.4
//--------------------------------------------------------------------
//  富永研究室  tominaga 富永浩之
//  2015.06.30
//====================================================================


//====================================================================
//  ヘッダファイル
//====================================================================

#include <stdio.h>
#include <stdlib.h>
#include "SimpleSortLib.h"


//====================================================================
//  単純整列算法  基本
//====================================================================

//--------------------------------------------------------------------
//  単純選択法
//--------------------------------------------------------------------

void sel_sort(Data arr[], int n) 
{
  int i, j;    // 反復変数
  int p;       // 最小要素の位置
  for ( i = 0; i < n-1; i++ ) {                 // n-1回の選択パス
    p = i;                                      // 最小候補の位置を格納
    for ( j = i+1; j < n; j++ ) {               // 整列部分の直後から配列末尾まで
      if ( ! arr_ord(arr, p, j) ) { p = j; }    // 最大要素の位置
    }
    arr_swap(arr, i, p);                        // 最小要素の交換
  }
}

//--------------------------------------------------------------------
//  単純交換法
//--------------------------------------------------------------------

void exch_sort(Data arr[], int n) 
{
  int i, j;    // 反復変数
  for ( i = 0; i < n-1; i++ ) {          // n-1回の交換パス
    for ( j = n-1; j > i; j-- ) {        // 配列末尾から左へ整列部分の直後まで
      if ( ! arr_ord(arr, j-1, j) ) {    // 隣接要素の比較
        arr_swap(arr, j-1, j);           // 隣接要素の交換
      }
    }  
  }
}

//--------------------------------------------------------------------
//  単純挿入法
//--------------------------------------------------------------------

void ins_sort(Data arr[], int n) 
{
  int i, j;    // 反復変数
  for ( i = 0; i < n-1; i++ ) {                 // n-1回の挿入パス
    for ( j = i; j >= 0; j-- ) {                // 整列部分の直後から左へ
      if ( arr_ord(arr, j, j+1) ) { break; }    // 挿入位置
      arr_swap(arr, j, j+1);                    // 隣接要素の交換
    }
  }
}


//====================================================================
//  単純整列算法  変種
//====================================================================

//--------------------------------------------------------------------
//  シェーカーソート
//--------------------------------------------------------------------

void shaker_sort(Data arr[], int n) 
{
  int i = 1;      // 左端
  int j = n-1;    // 右端
  int k;          // 反復変数
  while ( i < j ) {
    //----  左から右への交換処理
    for ( k = i; k < j; k++ ) {
      if ( ! arr_ord(arr, k-1, k) ) { 
        arr_swap(arr, k-1, k);
      }
    }
    //----  右から左への交換処理
    for ( k = j; k > i; k-- ) {
      if ( ! arr_ord(arr, k-1, k) ) { 
        arr_swap(arr, k-1, k); 
      }
    }
    i++;    // 左端位置を更新
    j--;    // 右端位置を更新
  }
}

//--------------------------------------------------------------------
//  ノームソート
//--------------------------------------------------------------------

void gnome_sort(Data arr[], int n) 
{
  int k = 1;                                          // 左端から開始
  while ( k < n ) {                                   // 右端に達するまで
    if ( arr_ord(arr, k-1, k) ) { k++; continue; }    // 正順なら右へ
    arr_swap(arr, k-1, k);                            // 逆順なら交換して左へ
    if ( k > 1 ) { k--; } else { k++; }               // 左端なら右へ
  }
}

//--------------------------------------------------------------------
//  奇偶転置ソート
//--------------------------------------------------------------------

void trans_sort(Data arr[], int n) 
{
  int k;              // 反復変数
  int flag = TRUE;    // 継続フラグ(交換の有無)
  while ( flag ) {    
    flag = FALSE;    // 反復内の最初に交換無に初期化
    //----  偶奇パス(0と1、2と3などの番目の組で比較)
    for ( k = 0; k < n-1; k += 2 ) {    
      if ( ! arr_ord(arr, k, k+1) ) { 
        arr_swap(arr, k, k+1); flag = TRUE; 
      }
    }
    //----  奇偶パス(1と2、3と4などの番目の組で比較)
    for ( k = 1; k < n-1; k += 2 ) {    
      if ( ! arr_ord(arr, k, k+1) ) { 
        arr_swap(arr, k, k+1); flag = TRUE; 
      }
    }
    // 両方のパスで交換が起きないとき、継続フラグが偽のままで、反復を終了
  }
}


//====================================================================
//  補助関数
//====================================================================

//--------------------------------------------------------------------
//  配列の要素の比較
//--------------------------------------------------------------------

Bool arr_ord(Data arr[], int p1, int p2) 
{
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}

//--------------------------------------------------------------------
//  配列の要素の交換
//--------------------------------------------------------------------

void arr_swap(Data arr[], int p1, int p2) 
{
  Data tmp;
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

//--------------------------------------------------------------------
//  配列の要素の挿入
//--------------------------------------------------------------------

void arr_ins(Data arr[], int p, int m) {              // m-p回の交換に相当
  Data tmp = arr[m];                                  // データを退避
  int k;
  for ( k = m; k > p; k-- ) { arr[k] = arr[k-1]; }    // データを後方移動
  arr[p] = tmp;                                       // データを挿入
}


//====================================================================
//  配列の入出力
//====================================================================

//--------------------------------------------------------------------
//  配列への入力
//--------------------------------------------------------------------

void arr_input(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { scanf("%2d", &arr[k]); }
}

//--------------------------------------------------------------------
//  配列からの出力
//--------------------------------------------------------------------

void arr_output(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { printf("%2d ", arr[k]); }
}

